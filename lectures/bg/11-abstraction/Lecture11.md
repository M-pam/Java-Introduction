# Lecture 11
#java course#

## Abstraction, Interfaces and Polymorphism 


### Abstraction

Абстракцията е един от основните принципи на ООП. Този принцип цели да изобличи основните
функционалности на една система, без да дава достъп до излишни детайли, които биха усложнили разбирането на система.

Използвайки този принцип ние можем да крием детайли и несъществени подробности на една система (подобно на енкапсулация).  
В същото време имаме възможността дадена част от системата да я направим достъпна.

С други думи можем да кажем, че абстракцията основно се фокусира в/у външния облик на системата (класовете).

> Знаете ли, че често употребявана дума за това е API (Application Programming Interface)?

Пример за абстракция от всекидневието:
- Когато караме една кола ние имаме досег само до волана, педалите и скоростния лост. 
Детайлите за това какво се случва при натискане на педала, завъртане на волана и смяна на предавка са скрити от нас.
Ние сме абстрахирани от тях.

### Interfaces

Интерфейсите са един от основните начини, чрез които може да се постигне **абстракция** в Java. 
Интерфейса, като концепция представлява описание на видимата (публичната) част от нашата програма
(тази която искаме да направим достъпна) за други части от програмата, други класове или други модули.

Конкретно в Java интерфейсите се прилагат на ниво класове. Един интерфейс описва какви методи и свойства има без да
предоставя тяло на методите, а класът, който имплементира този интерфейс е задължен да презапише методите от интерфейса.

![mechanical_watch_interfaces](../../../assets/11-lecture/mechanical_watch_interfaces.jpg)

> В този случай циферблата и стрелките на часовника могат да бъдат репрезентирани чрез **interface**, 
а механичните компоненти задвижващи стрелките са детайлите или така наречената имплементация на интерфейса.

Интерфейсите често намират приложение там, където различни логически компоненти е необходимо да комуникират, 
без да споделят детайли относно вътрешната си работа. Тази комуникация става чрез методите на интерфейса.
Това често се нарича **contract (договор)**. Различните компоненти извършват комуникацията през интерфейс,
който е известен и за двете страни на комуникацията.

![interface_contract_watch](../../../assets/11-lecture/interface_contract_watch.jpg)

> Всички знаем, как да разчитаме текущия час, използвайки часовник. Това е така защото сме наясно,
как можем да извлечем текущия час, минута и секунда от часовника използвайки неговите стрелки и циферблат (интерфейс).
Наясно сме с неговия **contract**. Ако начина по-който разбираме часът зависеше от други елементи,
които не са известни за нас, ние няма дам можем да определим часът. Или с други думи имаме друг **contract (договор)**.


Ето как изглежда един **interface** в Java и класът, който го имплементира.


```java
interface Watch {

    long getCurrentTime();
    
}

class DigitalWatch implements Watch {

    @Override
    public long getCurrentTime() {
        return System.currentTimeMillis();
    }
}
```

> Дефинирането става чрез използването на ключовата дума **interface** пред името на интерфейса.
Имплементирането на интерфейса става чрез ключовата дума **implements**, която се поставя
след името на класът, който го имплементира.

За разлика от наследяването един class може да имплементира множество интерфейси.
Също така един клас може и да наследява друг клас и едновременно да имплементира интерфейс.
Имплементиращият клас е длъжен да презапише (override) всички методи на interface, освен ако класът не е абстрактен.

Един интерфейс също така може да наследява друг интерфейс. Като за разлика от класовете интерфейсът няма ограничение на
броя интерфейси, които ще наследява. Обикновенно причината, поради която се налага един интерфейс да наследява друг е
ако трябва да се създаде някаква йерархична връзка м/у тези интерфейси. В този случай класът, които имплементира
такъв интерфейс е длъжен да презапише (override) всички методи идващи от интерфейсите.

- пример

```java
interface Animal {
    
    void breathe();
}

interface Human extends Animal {
    
    void think();
}

class Person implements Human {
    
    @Override
    public void breathe() {
        System.out.println("The person is breathing...");
    }
    
    @Override
    public void think() {
        System.out.println("The person is thinking...");
    }
}
```

> Класът `Person` е длъжен да презапише методите `breathe` и `think` понеже имплементира `Human`,
който от своя страна наследява `Animal`.


### Abstract class vs Interface

Приликите м/у абстракнти класове и интерфейси са много. Почти всичко, което може да се направи с интерфейси, може да се
постигне и с абстрактни класове (напрактика клас, на който всичките му методи са абстрактни, може да се разглежда, 
като интерфейс).


![abstract_class_vs_interface](../../../assets/11-lecture/abstract_class_vs_interface.png)


Въпреки това съществуват няколко разлики, които е хубаво да бъдат споменати.

- Всеки мето в един интерфейс е `abstract public` (което е излишно да се пише), докато при абстрактните класове,
абстрактните методи могат да са `package private`, `protected` или `public`

- Всички методи, които са дефинирани в един интерфейс ще бъдат имплементирани, като публични, докато при абстрактният
клас, наследникът не е длъжен да дава публичен достъп до методите, които е имплементирал 
(освен ако те не са изрично публични)

- В абстрактните класове, може да има методи, които не са абстрактни (имат тяло), докато при интерфейсите всички методи
са абстрактни. **ВАЖНО:** след Java 8 може да има методи с тяло в интерфейсите. Тези методи се наричат **default**.
С тази промяна в Java се запълва най-голямата разлика м/у интерфейси и абстрактни класове. Също така, след тази версия
е възможно в интерфейсите да се пишат и **static** методи.

- Един клас може да имплементира множество интерфейси, докато броят на класовете, които може да наследява е само един.

- Един интерфейс може да наследява един или множество интерфейси. 

- Когато едно property е дефинирано в интерфейс, то това property е static (излишно е да се пише). Интерфейсите не
могат да имат свойства, които да имат различни стойности в отделни инстанции, за разлика от абстрактните класове.

### Polymorphism

Полиморфизмът е друг основен принцип от ООП. Този принцип описва способността на 
един обект да приема много форми. Най-честата употреба на полиморфизъм в ООП, е когато
се използва референция на `super class` за да се реферира `child class`. 

![bird_morph_into_plain](../../../assets/11-lecture/bird_morph_into_plain.jpg)

Така например ако имаме клас `Bird (птица)`, който имплементира или наследява `Flyer (летец)`, то тогава можем да реферираме,
птицата чрез летеца.

- Пример

```java
interface Flyer {
    
    void fly();
}

class Bird implements Flyer {
    
    @Override
    public void fly() {
        System.out.println("Flap wings");
    }
}

class Airplane implements Flyer {
    
    @Override
    public void fly() {
        System.out.println("Starting engines");
    }
}

class Main {

    public static void main(String[] args) {
        Flyer bird = new Bird();
        Flyer airplane = new Airplane();
        Airplane secondAirplane = new Airplane();

        startFlying(bird); // Bird приема формата на Flyer
        startFlying(airplane); // Airplane приема формата на Flyer
        startFlying(secondAirplane); // Airplane приема формата на Flyer
    }

    /**
     * Този метод приема {@link Flyer}.
     * Той е абстрахиран от {@link Bird} и {@link Airplane}.
     *
     * @param flyer инстанция, която ще полети.
     */
    private static void startFlying(Flyer flyer) {
        flyer.fly();
    }
}
```

>  В първия случай, когато се извиква методът `startFlying(bird)` ще се принтира `Flap wings`,
а във останалите два ще се принтира `Starting engines`.

Това свойство на ООП позволява в една програма да бъде изграждана логика, която зависи 
на абстракции (в този случай `Flyer`) и в същото време да съществуват конкретни репрезентации
на тези абстракции (в този случай `Bird` и `Airplane`). Тези конкретни репрезентации, могат да се представят
за по-високото ниво на абстракция `(Up-Casting)`.

##### Up Casting

```java
Flyer bird = new Bird(); // Bird приема по-високото ниво на абстракция Flyer
```
> Това е възможно защото `Bird` имплементира `Flyer`, в противен случай този ред няма да компилира.

##### Down Casting

Както конкретния тип може да се представи за типът, който имплементира или наследява, така и обратното е възможно.
Ако имаме променлива от тип на някой `super class`, то можем да направим **down cast** или просто **cast** за да 
получим променлива от тип `child class`.

```java
private static void startFlying(Flyer flyer) {
    Bird bird = (Bird) flyer;
    bird.fly();
}
```

Този тип cast не е безопасен, тъй като може да се окаже че променливата, която се опитваме да кастнем няма нищо общо
с типа, към който я кастваме. В този случай би се получила грешка по време на изпълнение на програмата.

##### instance of

За да се избегнат грешки при down casting, може да се използва ключовата дума `instanceof` за да се извърши проверка,
за типът на променливата.

```java
private static void startFlying(Flyer flyer) {
    if (flyer instanceof Bird) {
        Bird bird = (Bird) flyer;
        bird.fly();
    }
}
```

### Lists

Масивите имат фиксиран брой елементи. Те не могат да нарастват или намаляват. Което означава че предварително
трябва да се знае, колко точно елемента, ще има в нашия масив.

Затова Java предоставя така наречения списък `ArrayList`, който представлява поредица от данни, точно като масив с
тази ралика, че размера му не е фиксиран. Един `ArrayList` може да бъде итериран, да се добавят нови елементи, да се 
премахват елементи и да се проверява дали съществуват елементи в този списък, като съществуват и други функционалности.

- add(...) - добавя най отзад в списъка
- remove(...) - премахване на конкретен елемент от списъка
- clear() - премахва елементите от списъка
- size() - връща размера на списъка
- get(...) - вземаме елемент на определен индекс от списъка
- contains(...) - проверява дали съществува даден елемент в списъка
- toArray() - връща масивът, от който е съставен списъка

Един `List` може да съдържа елементи от точно определен тип. За целта, когато се създава списъкът трябва да се 
упомене, какъв тип елементи ще се записват в този списък.

- Пример

```java
List<Car> cars = new ArrayList<>(); // понеже сме добавили <Car> това означава че този списък е само от коли

cars.add(new Car("BMW"));
cars.add(new Car("Audi"));

for (Car car : cars) {
    System.out.println(car);
}

for (int i = 0; i < cars.size(); i++){
    System.out.println(cars.get(i));
}
```
> Ако списъкът нямаше типът на елементите `<Car>`, то тогава щеше да може да се добавят елементи от всякакъв тип.
Ето пример за списък без тип на елементите `List cars = new ArrayList();`

## Tasks

### Task 1

Създайте програма, която моделира зоологическа градина с котка (cat) 🐈, куче (dog) 🐕 и птица (bird) 🦜.

Една зоологическа градина (zoo) има следните характеристики:
- списъкт от животни (`List<Animal> animals`)

Една зоологическа градина има следното поведение:
- може да добавя нови животни (add animal)
- може да храни всичките животни (feed animals)

Едно животно (Animal) има следното поведение:
- животното може да яде (eat)

Всяко едно животно, когато яде принтира на конзолата `Cat is eating`, `Dog is eating` и `Bird is eating`
респективно за котка, куче и птица.

> Решете задачата използвайки интерфейс. `Animal` ще е интерфейс с метод `void eat()`, а `Cat`, `Dog` и `Bird` ще 
са отделни класове, които имплементират този интерфейс.

#### 1.1

Създайте, нов тип персийска котка (persian cat), която когато яде принтира `Persian cat is eating`.  
Добавете в този нов тип метод за играене (play), който принтира `Persian cat is having fun`.  
Модифицирайте така зоологическата градина, че когато се хранят животните при попадането на новата котка да се извика
метода за игра.

<br/><details><summary><b>Solution</b> 👀</summary> 
<p>

- Animal.java

```java
public interface Animal {

    void eat();
}
```

- Bird.java

```java
public class Bird implements Animal {

    @Override
    public void eat() {
        System.out.println("Bird is eating...");
    }
}
```

- Dog.java

```java
public class Dog implements Animal {

    @Override
    public void eat() {
        System.out.println("Dog is eating...");
    }
}
```

- Cat.java

```java
public class Cat implements Animal {

    @Override
    public void eat() {
        System.out.println("Cat is eating...");
    }
}
```

- PersianCat.java

```java
public class PersianCat extends Cat {

    void play() {
        System.out.println("Persian cat is having fun...");
    }

    @Override
    public void eat() {
        System.out.println("Persian cat is eating...");
    }
}
```

- Zoo.java
```java
import java.util.ArrayList;
import java.util.List;

public class Zoo {

    private List<Animal> animals = new ArrayList<>();

    public void add(Animal animal) {
        this.animals.add(animal);
    }

    public void feedAnimals() {
        for (Animal animal : animals) {

            if (animal instanceof PersianCat) { // проверяваме дали животното е PersianCat
                PersianCat persianCat = (PersianCat) animal; // кастваме Animal към PersianCat
                persianCat.play();
            }

            animal.eat();
        }
    }
}
```

- ZooDemo.java

```java
public class ZooDemo {

    public static void main(String[] args) {

        Animal bird = new Bird();
        Animal cat = new Cat();
        Animal dog = new Dog();
        Animal persianCat = new PersianCat();

        Zoo zoo = new Zoo();

        zoo.add(bird);
        zoo.add(cat);
        zoo.add(dog);
        zoo.add(persianCat);

        zoo.feedAnimals();
    }
}
```

</p>
</details>
